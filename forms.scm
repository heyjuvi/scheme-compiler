(define (immediate? x)
  (cond
    ((fixnum? x) #t)
    ((char? x) #t)
    ((boolean? x) #t)
    ((null? x) #t)
    (else #f)))

(define (primcall-operator x) (car x))
(define (primcall-operand1 x) (cadr x))
(define (primcall-operand2 x) (caddr x))
(define (primcall? x)
  (if (list? x)
    (let ((op (primcall-operator x)))
      (or
        (eq? op 'add1)
        (eq? op 'sub1)
        (eq? op '+)
        (eq? op '-)
        (eq? op 'equal?)
        (eq? op 'cons)
        (eq? op 'car)
        (eq? op 'cdr)))
    #f))

(define (if? x) (tagged-list? x 'if))
(define (if-test x) (cadr x))
(define (if-conseq x) (caddr x))
(define (if-altern x) (cadddr x))

(define (let? x) (tagged-list? x 'let))
(define (let-bindings x) (cadr x))
(define (let-binding-var x) (car x))
(define (let-binding-val x) (cadr x))
(define (let-body x) (cddr x))
(define (make-let bindings body)
  (cons 'let (cons bindings body)))

(define (begin? x) (tagged-list? x 'begin))
(define (begin-body x) (cdr x))
(define (make-begin body)
  (cond
    ((null? body) (error "begin body must not be empty"))
    ((null? (cdr body)) (car body))
    (else (cons 'begin body))))

(define (cond? x) (tagged-list? x 'cond))
(define (cond-clauses x) (cadr x))
(define (cond-clause-test x) (car x))
(define (cond-clause-body x) (cadr x))

(define (var? x) (symbol? x))
(define (local-var? x) (eq? (string-ref x 0) #\%))
(define (global-var? x) (eq? (string-ref x 0) #\%))
(define (make-local-var str) (string-append "%" str))
(define (make-global-var str) (string-append "@" str))
