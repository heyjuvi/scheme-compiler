(define global-env '())
(define (add-global-var var val)
  (set! global-env (extend-env var val global-env)))

(define functions '())
(define (add-function x)
  (set! functions (cons x functions)))

(define (extract-global-vars top-level)
  (for-each
    (lambda (x)
      (if (define-var? x)
	(let* ((global-symbol (define-id x))
	       (global-name (symbol->string global-symbol))
	       (global (string-append "@" global-name)))
	  (add-global-var global-symbol global))
	'no-global-definition))
  top-level))

(define lambda-name-counter 0)
(define (unique-lambda-name)
  (set! lambda-name-counter (add1 lambda-name-counter))
  (format "lambda~A" lambda-name-counter))

(define (lambdas->closures x)
  (cond ((define-var? x)
	 (make-define-var (define-id x)
			  (lambdas->closures (define-body x))))
	((closure? x) x)
	((lambda? x)
	 (let ((arity (length (lambda-args x)))
	       (name (unique-lambda-name))
	       (free (free-vars x)))
	   (let* ((function-args (cons 'c_env (lambda-args x)))
		  ; the body should be wrapped by begin at this stage
		  (converted-body (lambdas->closures (car (lambda-body x))))
		  ; maybe unnecessary because of c-env unpacking?
		  (substituted-body (free-vars->env-refs converted-body free)))
             (add-function (make-function name
					  function-args
					  free
					  (make-body substituted-body))))
	   (make-closure name arity free)))
	((quote? x)
	 (make-quote (lambdas->closures (quote-content x))))
	((list? x) (map lambdas->closures x))
	((immediate? x) x)
	((var? x) x)
	((string? x) x)
	(else (error "not implemented" (car x)))))

(define (free-vars x)
  (debug "FREE-VARS -- x = ") (debug x) (debug-newline)
  (cond
    ((closure? x) (closure-free-vars x))
    ((lambda? x)
     ; the body should be wrapped by begin at this stage
     (set-substract (free-vars (car (lambda-body x)))
		    (lambda-args x)))
    ((if? x)
     (set-union (free-vars (if-test x))
		(set-union (free-vars (if-conseq x))
			   (free-vars (if-altern x)))))
    ((begin? x)
     (free-vars (begin-body x)))
    ((let? x)
     (set-union (set-union-many (map free-vars (let-bindings-vals x)))
		(set-substract (free-vars (let-body x))
                               (let-bindings-vars x))))
    ((immediate? x) '())
    ((string? x) '())
    ((quote? x) '())
    ((null? x) '())
    ((primcall? x) (set-union-many (map free-vars (cdr x))))
    ((list? x) (set-union-many (map free-vars x)))
    ((and (var? x) (not (assoc x global-env)))
     (list x))
    (else '())))

(define (free-vars->env-refs_ x reps)
  (cond
    ((var? x)
     (let ((var-rep (assoc x reps)))
       (if (eq? var-rep #f)
         x
         (cdr var-rep))))
    ; TODO: let
    ((immediate? x) x)
    ((string? x) x)
    ((quote? x) x)
    ((null? x) x)
    ((closure? x) x)
    ;((closure? x)
    ; (make-closure (closure-function x)
    ;               (closure-arity x)
    ;               (free-vars->env-refs_ (closure-free-vars x) reps)))
    ((list? x) (map (lambda (y) (free-vars->env-refs_ y reps)) x))
    (else (error "not implemented" (car x)))))
(define (free-vars->env-refs x free)
  (let ((reps (indexed-map (lambda (i e) `(,e list-ref c_env ,i))
	                    free)))
    (free-vars->env-refs_ x reps)))

