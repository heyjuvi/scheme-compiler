(define global-env '())
(define (add-global-var var val)
  (set! global-env (extend-env var val global-env)))

(define functions '())
(define (add-function x)
  (set! functions (cons x functions)))

(define (extract-global-vars top-level)
  (for-each
    (lambda (x)
      (if (define-var? x)
	(let* ((global-symbol (define-id x))
	       (global-name (symbol->string global-symbol))
	       (global (string-append "@" global-name)))
	  (add-global-var global-symbol global))
	'no-global-definition))
  top-level))

(define lambda-name-counter 0)
(define (unique-lambda-name)
  (set! lambda-name-counter (add1 lambda-name-counter))
  (format "lambda~A" (list lambda-name-counter)))

(define (lambdas->closures x)
  (cond ((define-var? x)
	 (make-define-var (define-id x)
			  (lambdas->closures (define-body x))))
	((closure? x) x)
	((lambda? x)
	 (let ((arity (length (lambda-args x)))
	       (name (unique-lambda-name))
	       (free (free-vars x)))
	   (let* ((function-args (cons 'c_env (lambda-args x)))
		  ; the body should be wrapped by begin at this stage
		  (converted-body (lambdas->closures (car (lambda-body x))))
		  ; maybe unnecessary because of c-env unpacking?
		  (substituted-body (free-vars->env-refs converted-body free)))
	     (debug "LAMBDAS->CLOSURES -- Constructing new function") (debug-newline)
	     (debug (format "  function args: ~A" (list function-args))) (debug-newline)
	     (debug (format "  free vars: ~A" (list free))) (debug-newline)
	     (debug (format "  converted body: ~A" (list converted-body))) (debug-newline)
	     (debug (format "  substituted body: ~A" (list substituted-body))) (debug-newline)
             (add-function (make-function name
					  function-args
					  free
					  (make-body substituted-body))))
	   (make-closure name arity free)))
	((myquote? x)
	 (make-myquote (lambdas->closures (myquote-content x))))
	((list? x) (map lambdas->closures x))
	((immediate? x) x)
	((var? x) x)
	((string? x) x)
	(else (error "not implemented" (car x)))))

(define (free-vars x)
  (debug "FREE-VARS -- x = ") (debug x) (debug-newline)
  (cond
    ((closure? x) (closure-free-vars x))
    ((lambda? x)
     ; the body should be wrapped by begin at this stage
     (set-substract (free-vars (car (lambda-body x)))
		    (lambda-args x)))
    ((if? x)
     (set-union (free-vars (if-test x))
		(set-union (free-vars (if-conseq x))
			   (free-vars (if-altern x)))))
    ((begin? x)
     (free-vars (begin-body x)))
    ((let? x)
     (set-union (set-union-many (map free-vars (let-bindings-vals x)))
		(set-substract (free-vars (let-body x))
                               (let-bindings-vars x))))
    ((immediate? x) '())
    ((string? x) '())
    ((vector-primcall? x) (set-union-many (map free-vars (cdr x))))
    ((set!? x) (free-vars (set!-val x)))
    ((myquote? x) '())
    ((null? x) '())
    ((or (primcall? x) (vector-primcall? x) (list-primcall? x))
     (set-union-many (map free-vars (cdr x))))
    ((list? x) (set-union-many (map free-vars x)))
    ((and (var? x) (not (assoc x global-env)))
     (debug "entering var") (debug-newline)
     ;(debug "entering var (but why?)") (debug (assoc x global-env)) (debug-newline)
     (debug "global env: ") (debug global-env) (debug-newline)
     (list x))
    (else '())))

(define (free-vars->env-refs_ x reps)
  (cond
    ((var? x)
     (let ((var-rep (assoc x reps)))
       (if (eq? var-rep #f)
         x
         (cdr var-rep))))
    ; TODO: let
    ((immediate? x) x)
    ((string? x) x)
    ((myquote? x) x)
    ((closure? x) x)
    ;((closure? x)
    ; (make-closure (closure-function x)
    ;               (closure-arity x)
    ;               (free-vars->env-refs_ (closure-free-vars x) reps)))
    ((list? x)
     (map (lambda (y) (free-vars->env-refs_ y reps)) x))
    (else
      (error "free-vars->env-refs has not implemented" (car x)))))
(define (free-vars->env-refs x free)
  (debug "FREE-VARS->ENV-REFS -- x = ") (debug x) (debug-newline)
  (debug "FREE-VARS->ENV-REFS -- free = ") (debug free) (debug-newline)
  (let ((reps (indexed-map (lambda (i e) `(,e list-ref c_env ,i))
	                    free)))
    (free-vars->env-refs_ x reps)))

